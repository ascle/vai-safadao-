Package compilador;
 
Helpers     
    hcharmin = ['a' .. 'z']+;
    hcharmai = ['A' .. 'Z']+;
    hchar = hcharmin|hcharmai;
    hdigito = ['0' .. '9']+;
    hdigito_octal = ['0' .. '7']+;
    hdigito_hexadecimal = (['0' .. '9'] | ['A' .. 'F'] | ['a' .. 'f'])+;
    hqualquer_char = [0x0 .. 0xffff];
    
    hunderscore = '_';
    
    hcr = 13 ;
    hlf = 10 ;
    htab = 9 ;
    hblank = ' ';
    hponto_e_virgula = ';';
    hidentacao = [10 + htab];
    /* hbarran = '\n'; */
    hchar_ignored = hcr|hblank|'\n';
    hnao_cr_lf = [hqualquer_char - [13 + 10]];
    hnao_estrela = [hqualquer_char - '*'];
    hnao_estrela_barra = [hnao_estrela - '/'];    
 
Tokens
    tnumero = hdigito+;
    tnumerooctal = '0' hdigito_octal+;
    tnumerohexa = '0' ('x'|'X') hdigito_hexadecimal+;
    
    tcomment_line = '//' (hnao_cr_lf)*;
    tcoment_bloco = '/*' hnao_estrela* '*'+ (hnao_estrela_barra hnao_estrela* '*'+)* '/';
    
    tnome_programa = hcharmai (hcharmin|hcharmai)*;
    
    tstring = ''' [hnao_cr_lf - ''']+ ''';
    
    tespaco = ' ';
    tquebra = hlf;
    
    tidentacao = hidentacao;
    
    tadicao = '+';
    tsubtracao = '-';
    tbarra = '/';
    testrela = '*';
    
    tmenor = '<';
    tmenor_igual = '<=';
    tmaior = '>';
    tmaior_igual = '>=';
    
    tseta = '<-';
    tigual_igual = '==';
    tdiferente = '!=';
    tigual = '=';    
 
    tdelimitador = hponto_e_virgula;
    tvirgula = ',';
    tabre_paren = '(' ;
    tfecha_paren = ')' ;
    tabre_colchete = '[' ;
    tfecha_colchete = ']' ;
    tabre_chave = '{' ;
    tfecha_chave = '}' ;
    tabre_coment = '/*' ;
    tfecha_coment = '*/' ;
    tponto = '.';
    tdoispontos = ':';
    
   tand_logico = '&&';
   tor_logico = '||';
   tnot_logico = '!';
   tdeclaracao_atribuicao = ':=';
   tellipsis = '...';
    
   tdefault = 'default';
   tcase = 'case';
   tif = 'if';
   telse = 'else';
   tfunc = 'func';
   tdefer = 'defer';
   treturn = 'return';
   trange = 'range';
   tfor = 'for';
   tvar = 'var';
   tconst = 'const';
    
   tbool = 'bool';
   tint32 = 'int32';
   tint64 = 'int64';
   ttipo = ('bool' | 'int32' | 'int64');
    
   tidentifier = (hunderscore|hchar) (hchar|hdigito)*;
   tchar_ignored = hchar_ignored | hlf;
    
    
Ignored Tokens
	tchar_ignored,
  tcomment_line;

Productions 

  expr =  {factor} factor |
      {adicao} expr tadicao factor |
      {subtracao} expr tsubtracao factor;
  factor =
      {term} term |
      {estrela} factor testrela term |
      {barra} factor tbarra term;
  term =
      {tnumero} tnumero |
      {expr} tabre_paren expr tfecha_paren;




  pidentifier_list =  { pmais_identificadores } tidentifier;
  pmais_identificadores = tidentifier tvirgula;

  /*
  pconst_decl = tconst ( pconst_spec | tabre_paren { pconst_spec tdelimitador } tfecha_paren ) ;
  pconst_spec = pidentifier_list [ [ ptype ] tigual pexpression_list ] ;

  pvar_decl = var ( pvar_spec | abre_paren { pvar_spec ponto_e_virgula } fecha_paren ) ;
  pvar_spec = pidentifier_list ( ptype [ tigual pexpression_list ] | tigual pexpression_list ) ;

  pdeclaration = pconst_decl | pvar_decl ;

  pfunction_decl = func pfunction_name ( pfunction | psignature ) ;
  pfunction_name = identifier ;
  pfunction = psignature pfunction_body ;
  pfunction_body = pblock ;

  pprogram = { ptopLevel_decl delimitador } ;
  ptopLevel_decl = pdeclaration | pfunction_decl | pmethod_decl  ;

  

  pexpression_list = pexpression { virgula pexpression } ;
  pexpression = punary_expr | pexpression pbinary_op pexpression ;
  punary_expr = pprimary_expr | punary_op punary_expr ;
  pbinary_op = or_logico | tand_logico | prel_op | padd_op | pmul_op ;
  prel_op = igual_igual | tmenor | tmaior ;
  padd_op = adicao | subtracao ;
  pmul_op = estrela | barra ;
  punary_op = adicao | subtracao | not_logico ;

  pprimary_expr = poperand | pconversion | pprimary_expr pindex | pprimary_expr parguments ;
  poperand = pliteral | identifier | abre_paren pexpression fecha_paren ;

  pliteral = pbasic_lit | pcomposite_lit | pfunction_list ;
  pbasic_lit = int_lit ;

  pcomposite_lit = pliteral_type pliteral_value ;
  pliteral_type = parray_type | abre_colchete ellipsis fecha_colchete pelement_type ;
  pliteral_value = abre_chave [ pelement_lit [ virgula ] ] fecha_chave ;
  pelement_lit = pkeyed_element { virgula pkeyed_element } ;
  pkeyed_element = [ pkey doispontos ] pelement ;
  pkey = pfield_name| pexpression | pliteral_value ;

  pfield_name= identifier ;
  pelement = pexpression | pliteral_value ;

  pfunction_list = func pfunction ;

  pconversion = ptype abre_paren pexpression [ virgula ] fecha_paren ;
  pindex = abre_colchete pexpression fecha_colchete ;
  parguments = abre_paren [ ( pexpression_list | ptype [ virgula pexpression_list ] ) [ ellipsis ] [ virgula ] ] fecha_paren ;

  

  pblock = abre_chave pstatement_list fecha_chave ;
  pstatement_list = { pstatement ponto_e_virgula } ;

  pmethod_decl  = func preceiver  pmethodName ( pfunction | psignature ) ;
  preceiver  = pparameters ;
  pmethodName = identifier ;
  pparameters = abre_paren [ pparameter_list [ virgula ] ] fecha_paren ;
  pparameter_list = pparameter_decl { virgula pparameter_decl } ;
  pparameter_decl = [ pidentifier_list ] ptype ;

  pstatement = pdeclaration | psimple_stmt | preturn_stmt | pblock | pif_stmt  | pfor_stmt ;

  psimple_stmt = pempty_stmt | pexpression_stmt | passignment | pshortpvar_decl ;
  pempty_stmt = ;
  pexpression_stmt = pexpression ;
  passignment = pexpression_list igual pexpression_list ;
  pshortpvar_decl = pidentifier_list declaracao_atribuicao pexpression_list ;

  preturn_stmt = return [ pexpression_list ] ;

  pif_stmt  = if [ psimple_stmt ponto_e_virgula ] pexpression pblock [ else ( pif_stmt  | pblock ) ] ;

  pfor_stmt = for [ pcondition | pfor_clause | prange_clause ] pblock ;
  pcondition = pexpression ;
  pfor_clause = [ pinit_stmt ] ponto_e_virgula [ pcondition ] ponto_e_virgula [ ppost_stmt ] ;
  prange_clause = [ pexpression_list igual | pidentifier_list declaracao_atribuicao ] range pexpression ;

  pinit_stmt = psimple_stmt ;
  ppost_stmt = psimple_stmt ;

  ptype = ptype_name | ptype_list | abre_paren ptype fecha_paren ;
  ptype_name = identifier ;
  ptype_list = parray_type | pfunctionptype ;

  parray_type = abre_colchete parray_length fecha_colchete pelement_type ;
  parray_length = pexpression ;
  pelement_type = ptype ;
  pfunctionptype = func psignature ;

  psignature = pparameters [ presult ] ;
  presult = pparameters | ptype ;
  pparameters = abre_paren [ pparameter_list [ virgula ] ] fecha_paren ;
  pparameter_list = pparameter_decl { virgula pparameter_decl } ;
  pparameter_decl = [ pidentifier_list ] [ ellipsis ] ptype ;  

*/