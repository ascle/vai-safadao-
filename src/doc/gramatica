Package compilador;
 
Helpers     
    hcharmin = ['a' .. 'z']+;
    hcharmai = ['A' .. 'Z']+;
    hchar = hcharmin|hcharmai;
    hdigito = ['0' .. '9']+;
    hdigito_octal = ['0' .. '7']+;
    hdigito_hexadecimal = (['0' .. '9'] | ['A' .. 'F'] | ['a' .. 'f'])+;
    hqualquer_char = [0x0 .. 0xffff];
    
    hunderscore = '_';
    
    hcr = 13 ;
    hlf = 10 ;
    htab = 9 ;
    hblank = ' ';
    hponto_e_virgula = ';';
    hidentacao = [10 + htab];
    /* hbarran = '\n'; */
    hchar_ignored = hcr|hblank|'\n';
    hnao_cr_lf = [hqualquer_char - [13 + 10]];
    hnao_estrela = [hqualquer_char - '*'];
    hnao_estrela_barra = [hnao_estrela - '/'];    
 
Tokens
    tnumero = hdigito+;
    tnumerooctal = '0' hdigito_octal+;
    tnumerohexa = '0' ('x'|'X') hdigito_hexadecimal+;
    
    tcomment_line = '//' (hnao_cr_lf)*;
    tcoment_bloco = '/*' hnao_estrela* '*'+ (hnao_estrela_barra hnao_estrela* '*'+)* '/';
    
    tnome_programa = hcharmai (hcharmin|hcharmai)*;
    
    tstring = ''' [hnao_cr_lf - ''']+ ''';
    
    tespaco = ' ';
    tquebra = hlf;
    
    tidentacao = hidentacao;
    
    tadicao = '+';
    tsubtracao = '-';
    tbarra = '/';
    testrela = '*';
    
    tmenor = '<';
    tmenor_igual = '<=';
    tmaior = '>';
    tmaior_igual = '>=';
    
    tseta = '<-';
    tigual_igual = '==';
    tdiferente = '!=';
    tigual = '=';    
 
    tdelimitador = hponto_e_virgula;
    tvirgula = ',';
    tabre_paren = '(' ;
    tfecha_paren = ')' ;
    tabre_colchete = '[' ;
    tfecha_colchete = ']' ;
    tabre_chave = '{' ;
    tfecha_chave = '}' ;
    tabre_coment = '/*' ;
    tfecha_coment = '*/' ;
    tponto = '.';
    tdoispontos = ':';
    
   tand_logico = '&&';
   tor_logico = '||';
   tnot_logico = '!';
   tdeclaracao_atribuicao = ':=';
   tellipsis = '...';
    
   tdefault = 'default';
   tcase = 'case';
   tif = 'if';
   telse = 'else';
   tfunc = 'func';
   tdefer = 'defer';
   treturn = 'return';
   trange = 'range';
   tfor = 'for';
   tvar = 'var';
   tconst = 'const';
    
   tbool = 'bool';
   tint32 = 'int32';
   tint64 = 'int64';
   ttipo = ('bool' | 'int32' | 'int64');
    
   tidentifier = (hunderscore|hchar) (hchar|hdigito)*;
   tchar_ignored = hchar_ignored | hlf;
    
    
Ignored Tokens
	tchar_ignored,
  tcomment_line;

Productions 

  pidentifier_list =  { pmais_identificadores } tidentifier;
  pmais_identificadores = tidentifier tvirgula;

  /*
  ConstDecl = const ( ConstSpec | abre_paren { ConstSpec ponto_e_virgula } fecha_paren ) ;
  ConstSpec = IdentifierList [ [ Type ] igual ExpressionList ] ;

  VarDecl = var ( VarSpec | abre_paren { VarSpec ponto_e_virgula } fecha_paren ) ;
  VarSpec = IdentifierList ( Type [ igual ExpressionList ] | igual ExpressionList ) ;

  Declaration = ConstDecl | VarDecl ;

  FunctionDecl = func FunctionName ( Function | Signature ) ;
  FunctionName = identifier ;
  Function = Signature FunctionBody ;
  FunctionBody = Block ;

  Program = { TopLevelDecl delimitador } ;
  TopLevelDecl = Declaration | FunctionDecl | MethodDecl ;

  

  ExpressionList = Expression { virgula Expression } ;
  Expression = UnaryExpr | Expression binary_op Expression ;
  UnaryExpr = PrimaryExpr | unary_op UnaryExpr ;
  binary_op = or_logico | and_logico | rel_op | add_op | mul_op ;
  rel_op = igual_igual | menor | maior ;
  add_op = adicao | subtracao ;
  mul_  op = estrela | barra ;
  unary_op = adicao | subtracao | not_logico ;

  PrimaryExpr = Operand | Conversion | PrimaryExpr Index | PrimaryExpr Arguments ;
  Operand = Literal | identifier | abre_paren Expression fecha_paren ;

  Literal = BasicLit | CompositeLit | FunctionLit ;
  BasicLit = int_lit ;

  CompositeLit = LiteralType LiteralValue ;
  LiteralType = ArrayType | abre_colchete ellipsis fecha_colchete ElementType ;
  LiteralValue = abre_chave [ ElementList [ virgula ] ] fecha_chave ;
  ElementList = KeyedElement { virgula KeyedElement } ;
  KeyedElement = [ Key doispontos ] Element ;
  Key = FieldName | Expression | LiteralValue ;

  FieldName = identifier ;
  Element = Expression | LiteralValue ;

  FunctionLit = func Function ;

  Conversion = Type abre_paren Expression [ virgula ] fecha_paren ;
  Index = abre_colchete Expression fecha_colchete ;
  Arguments = abre_paren [ ( ExpressionList | Type [ virgula ExpressionList ] ) [ ellipsis ] [ virgula ] ] fecha_paren ;

  

  Block = abre_chave StatementList fecha_chave ;
  StatementList = { Statement ponto_e_virgula } ;

  MethodDecl = func Receiver MethodName ( Function | Signature ) ;
  Receiver = Parameters ;
  MethodName = identifier ;
  Parameters = abre_paren [ ParameterList [ virgula ] ] fecha_paren ;
  ParameterList = ParameterDecl { virgula ParameterDecl } ;
  ParameterDecl = [ IdentifierList ] Type ;

  Statement = Declaration | SimpleStmt | ReturnStmt | Block | IfStmt | ForStmt ;

  SimpleStmt = EmptyStmt | ExpressionStmt | Assignment | ShortVarDecl ;
  EmptyStmt = ;
  ExpressionStmt = Expression ;
  Assignment = ExpressionList igual ExpressionList ;
  ShortVarDecl = IdentifierList declaracao_atribuicao ExpressionList ;

  ReturnStmt = return [ ExpressionList ] ;

  IfStmt = if [ SimpleStmt ponto_e_virgula ] Expression Block [ else ( IfStmt | Block ) ] ;

  ForStmt = for [ Condition | ForClause | RangeClause ] Block ;
  Condition = Expression ;
  ForClause = [ InitStmt ] ponto_e_virgula [ Condition ] ponto_e_virgula [ PostStmt ] ;
  RangeClause = [ ExpressionList igual | IdentifierList declaracao_atribuicao ] range Expression ;

  InitStmt = SimpleStmt ;
  PostStmt = SimpleStmt ;

  Type = TypeName | TypeLit | abre_paren Type fecha_paren ;
  TypeName = identifier ;
  TypeLit = ArrayType | FunctionType ;

  ArrayType = abre_colchete ArrayLength fecha_colchete ElementType ;
  ArrayLength = Expression ;
  ElementType = Type ;
  FunctionType = func Signature ;

  Signature = Parameters [ Result ] ;
  Result = Parameters | Type ;
  Parameters = abre_paren [ ParameterList [ virgula ] ] fecha_paren ;
  ParameterList = ParameterDecl { virgula ParameterDecl } ;
  ParameterDecl = [ IdentifierList ] [ ellipsis ] Type ;  

*/